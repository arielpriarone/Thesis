\section{Objective of the thesis}
\label{sec:objectives}

The goal of this thesis is to design, code and test a \emph{degradation based} \gls{cbm} framework that will perform \gls{nd}, \gls{fd} and \gls{pdm}, using one or several \gls{uml} algorithms. This framework is thought to be general purpose, needing just to receive time-series data from sensors, and to be set in training or evaluation mode.
This system will be implemented twice:
\begin{itemize}
    \item  coding in \texttt{\gls{glo:python}} and running it on a \gls{pc};
    \item   coding in \texttt{C} and running it on a microcontroller.
\end{itemize}

The development of the framework will be done modular and configurable, so that it will be easily adaptable to different use cases. Things like the number of sensors, the sampling frequency, and the number and types of \gls{glo:feature}s to extract will be easily configurable in a single file. The framework will be also designed to be easily expandable, so that new \gls{glo:feature}s can be added simply by developing a method that appends the new \gls{glo:feature} to the \gls{glo:feature} vector, without the need to modify the rest of the framework.

To do that, first, a real bearing vibration dataset published by \cite{IMSpaper} will be analyzed to decide how to preprocess the data, which \gls{glo:feature}s to extract and which algorithm to use. 
The candidate algorithms described in \autoref{ch:Unsupervised} will be applied to the dataset and the results will be compared. These algorithms are \textbf{K-means}, \textbf{\gls{dbscan}}, \textbf{Gaussian Mixture Model}, \textbf{Isolation Forest}, \textbf{Local Outlier Factor} and \textbf{One-Class support vector machine}. 

All of the tests will be carried out trying to follow the most unsupervised approach possible, so the only information used to train the algorithm will be the data itself. Every user input needed by the algorithm will be chosen using an easily automatable method, to preserve the unsupervised nature of the framework that will be developed. For example, user inputs are the number of \gls{glo:clust}s in K-means, or the radius in the \gls{dbscan}.

\maskkk{At the end of the analysis, considering the trade-off between the performance of the algorithm, the computational cost and the simplicity, K-means will be chosen as the algorithm to implement in a real-time framework, developed in \texttt{\gls{glo:python}}. Then, the data of the dataset will be polled from a database at regular intervals and fed to the framework to simulate a real sensor polling the signal directly from the machine and evaluate the real-time performance of the implementation. 

After that, a version of the framework with simplified architecture was implemented in \texttt{C} and tested on a \texttt{STM32F767ZI} microcontroller board.}

