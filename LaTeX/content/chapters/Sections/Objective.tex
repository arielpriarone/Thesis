\section{Objective of the thesis}
\label{sec:objectives}

The goal of this thesis is to design, code and test a \gls{cbm} framework that will perform \gls{nd}, \gls{fd} and \gls{pdm}. This framework is thought to be general purpose, it needs just to receive time-series data from sensors, and set in training or evaluation mode.
This system will be implemented twice:
\begin{itemize}
    \item  coding in \texttt{python} and running it on a \gls{pc};
    \item   coding in \texttt{C} and running it on a microcontroller.
\end{itemize}

The development of the framework has been done modular and configurable, so that it can be easily adapted to different use cases. Things like the number of sensors, the sampling frequency, and the number and types of features to extract are easily configurable in a single file. The framework is also designed to be easily expandable, so that new features can be added simply by developing a method that appends the new feature to the feature vector, without the need to modify the rest of the framework.

To do that first a real bearing vibration dataset published by \cite{IMSpaper} has been analyzed to decide how to preprocess the data, which features to extract and which algorithm to use. 
The candidate algorithms described in \autoref{ch:Unsupervised} have been applied to the dataset and the results have been compared. These algorithms are \textbf{K-means}, \textbf{\gls{dbscan}}, \textbf{Gaussian Mixture Model}, \textbf{Isolation Forest}, \textbf{Local Outlier Factor} and \textbf{One-Class support vector machine}. 

All of the tests have been done trying to follow the most unsupervised approach possible, so the only information used to train the algorithm has been the data itself. Every user input needed by the algorithm has been chosen using an easily automatable method, to preserve the unsupervised nature of the framework that will be developed. For example, user inputs are the number of clusters in K-means, or the radius in the \gls{dbscan}.

At the end of the analysis, considering the trade-off between the performance of the algorithm, the computational cost and the simplicity, K-means has been chosen as the algorithm to implement in a real-time framework, developed in texttt{python}. Then, the data of the dataset was polled from a database at regular intervals and fed to the framework to simulate a real sensor polling the signal from the machine and evaluate the real-time performance of the implementation.

After that, a version of the framework with simplified architecture has been implemented in \texttt{C} and tested on a \texttt{STM32F767ZI} microcontroller board.
