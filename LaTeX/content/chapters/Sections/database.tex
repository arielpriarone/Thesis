
\section{Database}
\label{sec:Database}
In the previous \autoref{sec:commissioning}, the setup behaviour phases of the \gls{glo:frmwrk} have been described, referring to a generic \quoted{database}, without specifying the structure of the database. Let's now address the problem of storing the data efficiently and effectively. Instead of relying on \texttt{\gls{glo:python}} data structures, it is better to use a dedicated database manager.

The proposed \gls{glo:frmwrk} uses \gls{glo:mongodb} for the following reasons. It is a widely-used, open-source \gls{glo:nosql} database that is designed to handle unstructured or semi-structured data. It utilizes a document-oriented data model, storing data in flexible, \gls{json}-like \gls{bson} format. \gls{glo:mongodb} is suitable for implementation in a \gls{nd} \gls{glo:frmwrk} due to its scalability, flexibility, and real-time data processing capabilities. In novelty detection, the system often deals with diverse and dynamic data sources, making \gls{glo:mongodb}'s \quoted{unstructureness} advantageous for handling varying data formats and evolving data requirements. It has the ability to handle large volumes of data and support scaling allowing for efficient storage and retrieval of information in real-time, crucial for real-time applications. Moreover, \gls{glo:mongodb} has a rich query language and secondary indexes that allow for fast and efficient querying of data and a library for \texttt{\gls{glo:python}} that makes it easy to use.
The \gls{json} format is also human-readable, which makes it easy to understand the data stored in the database, and \quoted{mongoDB Compass} is a graphical user interface that allows one to easily explore the database.

\subsection{Collections}
\begin{longtblr}[
  caption = {Collections contained in the \gls{glo:mongodb} database},
  label = {tab:MongoDB_collections},
  ]{
  hline{1,11} = {-}{0.08em},
      hline{2} = {-}{},
    }
  \textbf{Collection} & \textbf{Content}                                       \\
  raw                 & time-series and information about them                 \\
  unconsumed          & \gls{glo:snap}s to be evaluated                              \\
  quarantined         & {\gls{glo:snap}s detected as novelty waiting to be declared  \\healthy, faulty or be discarded}\\
  healthy             & \gls{glo:snap} declared as normal behaviour                 \\
  healthy train       & {training dataset (scaled, processed, packet)          \\for the \gls{nd} \gls{uml} model}\\
  faulty              & \gls{glo:snap}s declared as faulty behaviour                 \\
  faulty train        & {training dataset (scaled, processed, packet)          \\for the \gls{nd} \gls{uml} model}\\
  models              & {models trained on healthy and faulty data the metrics \\and predictions to be shown}\\
  backup              & time-series, \gls{glo:feature}s, models, etc.
\end{longtblr}

\gls{glo:mongodb} structure is based on collections, which are groups of (\gls{json}) documents. A document is a set of key-value pairs that can be nested in several layers. Documents have a dynamic schema, which means that documents in the same collection do not need to have the same set of fields or structure, and common fields in a collection's documents may hold different types of data. To store the data needed by the \gls{glo:frmwrk} the collections reported in \autoref{tab:MongoDB_collections} are used.
In the following paragraphs, the structure and purposes of each collection are described.

\paragraph{Raw}
Thinking about the data flow, the first interface between the hardware and the software would be the sensor readings. Every sensor should have a name and be sampled at a constant frequency (or, at least, the sensors that provide data for frequency-domain \gls{glo:feature} extraction should have a constant sampling frequency). This data is stored in the {raw} collection, with the \gls{json} structure summarized in \autoref{tab:raw_json},
where \texttt{\textunderscore id} is the unique identifier of the document, \texttt{timestamp} is the time at which the data was acquired, in \gls{iso} format, and \texttt{Sensor 1} to \texttt{Sensor n} are the names of the sensors. 

\begin{longtable}{lll}
  \caption{Structure of the \quoted{raw} collection \gls{json} configuration file.}\label{tab:raw_json}\\ 
  \toprule
  \textbf{Field} & \textbf{Sub-Field} & \textbf{Type} \endfirsthead 
  \hline
  \texttt{\textunderscore}id &  & string \\
  timestamp &  & \gls{iso} date \\*
  \multirow{2}{*}{sensor 1} & sampling frequency & float \\*
   & time-serie & list[float] \\*
  \multirow{2}{*}{sensor 2} & sampling frequency & float \\*
   & time-serie & list[float] \\
  $\dots$ & $\dots$ & $\dots$ \\*
  \multirow{2}{*}{sensor~$n$} & sampling frequency & float \\*
   & time-serie & list[float] \\
  \bottomrule
  \end{longtable}

  Each sensor has a \texttt{sampFreq} field that contains the sampling frequency of that particular sensor, and a \texttt{timeSerie} field that contains the data acquired by the sensor, as a list. The \texttt{timeSerie} field is a list of floating point numbers, that can be of any length. Note that the sampling frequencies of different sensors can be different, for example, if a timestamp contains $1\si{\s}$ period of data, a vibration sensor would be linked to an array with several thousands of samples, while a temperature sensor would be linked to only one sample.
  
\paragraph{Unconsumed}
Once defined the structure that the time-series will have in the database, let's define the structure of the \gls{glo:snap}s. The \gls{glo:feature}s extracted from the time-series are stored in the {unconsumed} collection, with the \gls{json} structure described in \autoref{tab:unconsumed_json}.

\begin{longtable}{lll}
  \caption{Structure of the \quoted{unconsumed} collection \gls{json} configuration file.}\label{tab:unconsumed_json}\\ 
  \toprule
  \textbf{Field} & \textbf{Sub-Field} & \textbf{Type} \endfirsthead 
  \hline
  \texttt{\textunderscore}id & - & string \\
  timestamp & - & \gls{iso} date \\
  \vcell{sensor 1} & \vcell{mean} & \vcell{float} \\*[-\rowheight]
  \printcelltop & \printcellmiddle & \printcellmiddle \\
   & root mean square & float \\
   & peak to peak & float \\
   & standard deviation & float \\
   & skewness & float \\
   & kurtosis & float \\
   & wavelet coefficient~$1$ & float \\
   & wavelet coefficient~$2$ ~ & float \\
   & $\vdots$ & $\vdots$ \\
   & wavelet coefficient~$2^{\text{three dept}}$ & float \\
  sensor 2 & mean & float \\
   & root mean square & float \\
   & peak to peak & float \\
   & standard deviation & float \\
   & skewness & float \\
   & kurtosis & float \\
   & wavelet coefficient~$1$ & float \\
   & wavelet coefficient~$2$ & float \\
   & $\vdots$ & $\vdots$ \\
   & wavelet coefficient~ $2^{\text{three dept}}$~~ & float \\
  $\vdots$ & $\vdots$ & $\vdots$ \\
  sensor~$n$ & mean & float \\
   & root mean square & float \\
   & $\vdots$ & $\vdots$ \\
   & wavelet coefficient~ ~~$2^{\text{three dept}}$ & float \\
  novelty evaluated flag & - & boolean \\
  \bottomrule
  \end{longtable}
  
Notice that different sensors can have different \gls{glo:feature}s. The \quoted{novelty evaluated} field is a boolean that is set to \texttt{false} when the \gls{glo:snap} is created, and is set to \texttt{true} when the \gls{nd} algorithm evaluates the \gls{glo:snap}. This field is used to avoid evaluating the same \gls{glo:snap} multiple times while leaving it in the collection until also the \gls{fd} algorithm is performed. At this point, the \gls{glo:snap} will be moved either to the backup collection, discarded or to the quarantine collection if either the \gls{nd} or the \gls{fd} flag it.

\paragraph{Quarantined}
The \quoted{quarantined} collection is used to store the \gls{glo:snap}s that were flagged as \quoted{novelty} by the \gls{nd} algorithm or as \quoted{faulty} by the \gls{fd} algorithm (or were flagged by both of them). The structure is the same as the \quoted{unconsumed} collection, but the \quoted{novelty evaluated} field is not present since, at this point, the \gls{glo:snap}s are guaranteed to have been evaluated. The \gls{glo:snap}s in this collection are waiting to be declared as \quoted{healthy} or \quoted{faulty} by the user or to be discarded.

\paragraph{Healthy}
The idea behind the \quoted{healthy} collection is to store the \gls{glo:snap}s that are acquired during the first work phase of the \gls{glo:frmwrk}, before training, or the \gls{glo:snap}s that were in the \quoted{quarantine} collection and were declared as healthy by the user. The documents in this collection have the same structure as the documents in the \quoted{quarantined} collection.

\paragraph{Healthy train}
In this collection the healthy \gls{glo:snap}s are packed together in different documents, each of them useful in a different phase of the training process.

{The first document has the \texttt{id} \texttt{training\textunderscore set}, that contains all the \texttt{N} training \gls{glo:snap}s, each of them with \texttt{n} sensors signals, characterized by \texttt{F} \gls{glo:feature}s. For ease of accessibility, every bottom-nested field is a list of \texttt{N} elements. The structure is resumed in \autoref{tab:train_json}.}


\begin{longtable}{lll}
\caption{Structure of the \quoted{healthy train} collection \gls{json} configuration file.}\label{tab:train_json}\\ 
\toprule
\textbf{Field} & \textbf{Sub-Field} & \textbf{Type} \endfirsthead 
\hline
\texttt{\textunderscore}id & - & string \\
timestamp & - & list[\gls{iso} date] \\
\vcell{sensor 1} & \vcell{\gls{glo:feature} 1} & \vcell{list[float]} \\*[-\rowheight]
\printcelltop & \printcellmiddle & \printcellmiddle \\
 & \gls{glo:feature} 2 & list[float] \\
 & $\vdots$ & $\vdots$ \\
 & \gls{glo:feature} F & list[float] \\
sensor 2 & \gls{glo:feature} 1 & list[float] \\
 & \gls{glo:feature} 2 & list[float] \\
 & $\vdots$ & $\vdots$ \\
 & \gls{glo:feature} F & llist[loat] \\
$\vdots$ & $\vdots$ & $\vdots$ \\
sensor~$n$ & \gls{glo:feature} 1 & list[float] \\
 & \gls{glo:feature} 2 & llist[loat] \\
 & $\vdots$ & $\vdots$ \\
 & \begin{tabular}[c]{@{}l@{}}\gls{glo:feature} F\\\end{tabular} & list[float] \\
\bottomrule
\end{longtable}


This collection contains other three documents:
\begin{itemize}
  \item \texttt{training set scaled}, that contains the scaled training set, having the same structure as the \texttt{training set} document;
  \item \texttt{training set MIN MAX}, that contains the minimum and maximum values of the \gls{glo:feature}s of the training set, useful to plot the \gls{glo:feature}s with a reference of the bounds of the training set. It has the same structure of the \texttt{training set} document, but the bottom-nested fields are lists of two elements (the minimum and the maximum value);
  \item \texttt{StandardScaler\textunderscore pickled}. It contains the \texttt{StandardScaler} object that was used to scale the training set. This object is encoded in \gls{glo:pickle}, and it is used during the evaluation phase to scale the \gls{glo:snap}s before evaluating them.
\end{itemize}

\paragraph{Faulty}
This collection serves the same exact purpose as the \quoted{healthy} collection, but for the faulty \gls{glo:snap}s. Faulty \gls{glo:snap}s are not discarded because they can be used to train the \gls{fd} \gls{uml} algorithm.

\paragraph{Faulty train}
This collection serves the same exact purpose as the \quoted{healthy train} collection, but for the faulty \gls{glo:snap}s.

\paragraph{Models}
This collection contains the models trained on the healthy and faulty data and a buffer of the predictions and metrics to be displayed to the user.

The structure of the models' documents is just an identifier and the \texttt{\gls{glo:python}} object of the model, encoded in \gls{glo:pickle}. The structure of the predictions and metrics documents is the \autoref{tab:model_json}:

\begin{longtable}{lll}
  \caption{Structure of the \quoted{models} collection \gls{json} configuration file.}\label{tab:model_json}\\ 
  \toprule
  \textbf{Field} & \textbf{Sub-Field} & \textbf{Type} \endfirsthead 
  \hline
  \texttt{\textunderscore}id & - & string \\
  timestamp & - & list[\gls{iso} date] \\
  values & - & list[float] \\
  assigned \gls{glo:clust} & - & list[int] \\
  anomaly flag & - & list[bool] \\
  prediction curve parameters & - & pickle format \\
  \bottomrule
  \end{longtable}

\paragraph{Backup}
The backup collection is a general-purpose container for any document that needs to be stored for backup purposes. It can contain time-series, \gls{glo:feature}s, models, etc. The structure of the documents in this collection is the same as the structure of the documents in the other collections.

