# %%

from cProfile import label
from calendar import c
from turtle import color
from matplotlib.patches import Shadow
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from pyparsing import col, line
from sklearn.datasets import make_blobs
from sklearn.cluster import KMeans
import src
from matplotlib.pyplot import cm
from matplotlib.colors import LightSource

def plot_sphere(ax, radius, center, color='b', alpha=0.1):
    u = np.linspace(0, 2 * np.pi, 100)
    v = np.linspace(0, np.pi, 100)
    x = center[0] + radius * np.outer(np.cos(u), np.sin(v))
    y = center[1] + radius * np.outer(np.sin(u), np.sin(v))
    z = center[2] + radius * np.outer(np.ones(np.size(u)), np.cos(v))
    ax.plot_surface(x, y, z, alpha=alpha, color=color, linewidth=0.1, zorder=1, linestyle='solid', antialiased=True)

src.vis.set_matplotlib_params()

# Generate random blobs
n_clusters = 2
X, y = make_blobs(n_samples=400, centers=n_clusters, n_features=3, random_state=0)

# Apply k-means clustering
kmeans = KMeans(n_clusters=n_clusters, random_state=42)
kmeans.fit(X)

# Plot the blobs and cluster centers
cmap = cm.tab10
colors = [cmap(i) for i in kmeans.labels_]

fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.scatter(X[:, 0], X[:, 1], X[:, 2], c=colors, marker='.', label='data')
ax.scatter(kmeans.cluster_centers_[:, 0], kmeans.cluster_centers_[:, 1], kmeans.cluster_centers_[:, 2], c='red', marker='x', label='centers')
ax.set_xlabel('Feature 1')
ax.set_ylabel('Feature 2')
ax.set_zlabel('Feature 3')

# Calculate the radius of each cluster
radii = []
for i in range(n_clusters):
    cluster_points = X[kmeans.labels_ == i]
    centroid = kmeans.cluster_centers_[i]
    distances = np.linalg.norm(cluster_points - centroid, axis=1)
    radius = np.max(distances)
    radii.append(radius)
    print(f"Cluster {i+1} radius: {radius}")

# Plot the smooth transparent surfaces
for i in range(n_clusters):
    plot_sphere(ax, radii[i], kmeans.cluster_centers_[i], color=cmap(i), alpha=0.1)

ax.set_aspect('equal')

# Generate a new random instance
new_instance = np.array([4, 1, 6])

# Assign the new instance to a cluster
new_instance_cluster = kmeans.predict([new_instance])[0]
ax.scatter(new_instance[0], new_instance[1], new_instance[2], c='magenta', marker='.', s=100, label='new instance')

# Plot an arrow from the center of the cluster to the new instance
ax.quiver(kmeans.cluster_centers_[new_instance_cluster][0], kmeans.cluster_centers_[new_instance_cluster][1], kmeans.cluster_centers_[new_instance_cluster][2],
          new_instance[0] - kmeans.cluster_centers_[new_instance_cluster][0], new_instance[1] - kmeans.cluster_centers_[new_instance_cluster][1], new_instance[2] - kmeans.cluster_centers_[new_instance_cluster][2],
          color='black', arrow_length_ratio=0.2, label='distance to center')

# Find the instance in the first cluster that is farthest from the center
cluster_points = X[kmeans.labels_ == 0]
centroid = kmeans.cluster_centers_[0]
distances = np.linalg.norm(cluster_points - centroid, axis=1)
farthest_instance_index = np.argmax(distances)
farthest_instance = cluster_points[farthest_instance_index]

# Plot an arrow from the center to the farthest instance
ax.quiver(kmeans.cluster_centers_[0][0], kmeans.cluster_centers_[0][1], kmeans.cluster_centers_[0][2],
          farthest_instance[0] - kmeans.cluster_centers_[0][0], farthest_instance[1] - kmeans.cluster_centers_[0][1], farthest_instance[2] - kmeans.cluster_centers_[0][2],
          color='red', arrow_length_ratio=0.2, label='radius')

ax.legend(loc='upper right', bbox_to_anchor=(2, 1))
plt.show()
